// Code generated by defc, DO NOT EDIT.

package main

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"text/template"
	"time"

	__rt "github.com/x5iu/defc/runtime"
	"github.com/x5iu/defc/sqlx"
)

func NewPersistence(drv string, dsn string) Persistence {
	return &implPersistence{
		__core: sqlx.MustOpen(drv, dsn),
	}
}

func NewPersistenceFromDB(core *sqlx.DB) Persistence {
	return &implPersistence{
		__core: core,
	}
}

func NewPersistenceFromCore(core PersistenceCoreInterface) Persistence {
	return &implPersistence{
		__core: core,
	}
}

type implPersistence struct {
	__withTx bool
	__core   PersistenceCoreInterface
}

func (__imp *implPersistence) SetWithTx(withTx bool) {
	__imp.__withTx = withTx
}

func (__imp *implPersistence) SetCore(core any) {
	__imp.__core = core.(PersistenceCoreInterface)
}

func (__imp *implPersistence) Clone() Persistence {
	var ()
	return &implPersistence{
		__withTx: __imp.__withTx,
		__core:   __imp.__core,
	}
}

func (__imp *implPersistence) Close() error {
	if closer, ok := __imp.__core.(interface{ Close() error }); ok {
		return closer.Close()
	}
	return nil
}

var (
	_ = (*template.Template)(nil)

	__PersistenceBaseTemplate = template.Must(template.New("PersistenceBaseTemplate").Funcs(template.FuncMap{"bindvars": __rt.BindVars, "fields": tableFields}).Parse(""))

	sqlTmpladdTTFTField     = template.Must(__PersistenceBaseTemplate.New("addTTFTField").Parse("alter table moonshot_requests add response_ttft integer;\r\n"))
	sqlTmpladdTPOTField     = template.Must(__PersistenceBaseTemplate.New("addTPOTField").Parse("alter table moonshot_requests add response_tpot integer;\r\n"))
	sqlTmpladdOTPSField     = template.Must(__PersistenceBaseTemplate.New("addOTPSField").Parse("alter table moonshot_requests add response_otps real;\r\n"))
	sqlTmpladdLatencyField  = template.Must(__PersistenceBaseTemplate.New("addLatencyField").Parse("alter table moonshot_requests add latency integer;\r\n"))
	sqlTmpladdEndpointField = template.Must(__PersistenceBaseTemplate.New("addEndpointField").Parse("alter table moonshot_requests add endpoint text;\r\n"))
	sqlTmplPersistence      = template.Must(__PersistenceBaseTemplate.New("Persistence").Parse("insert into moonshot_requests ( request_method, request_path, request_query, created_at {{ if .requestContentType }},request_content_type{{ end }} {{ if .requestID }},request_id{{ end }} {{ if .moonshotID }},moonshot_id{{ end }} {{ if .moonshotGID }},moonshot_gid{{ end }} {{ if .moonshotUID }},moonshot_uid{{ end }} {{ if .moonshotRequestID }},moonshot_request_id{{ end }} {{ if .moonshotServerTiming }},moonshot_server_timing{{ end }} {{ if .responseStatusCode }},response_status_code{{ end }} {{ if .responseContentType }},response_content_type{{ end }} {{ if .requestHeader }},request_header{{ end }} {{ if .requestBody }},request_body{{ end }} {{ if .responseHeader }},response_header{{ end }} {{ if .responseBody }},response_body{{ end }} {{ if .programError }},error{{ end }} {{ if .responseTTFT }},response_ttft{{ end }} {{ if .responseTPOT }},response_tpot{{ end }} {{ if .responseOTPS }},response_otps{{ end }} {{ if .latency }},latency{{ end }} {{ if .endpoint }},endpoint{{ end }} ) values ( :requestMethod, :requestPath, :requestQuery, :createdAt {{ if .requestContentType }},:requestContentType{{ end }} {{ if .requestID }},:requestID{{ end }} {{ if .moonshotID }},:moonshotID{{ end }} {{ if .moonshotGID }},:moonshotGID{{ end }} {{ if .moonshotUID }},:moonshotUID{{ end }} {{ if .moonshotRequestID }},:moonshotRequestID{{ end }} {{ if .moonshotServerTiming }},:moonshotServerTiming{{ end }} {{ if .responseStatusCode }},:responseStatusCode{{ end }} {{ if .responseContentType }},:responseContentType{{ end }} {{ if .requestHeader }},:requestHeader{{ end }} {{ if .requestBody }},:requestBody{{ end }} {{ if .responseHeader }},:responseHeader{{ end }} {{ if .responseBody }},:responseBody{{ end }} {{ if .programError }},:programError{{ end }} {{ if .responseTTFT }},:responseTTFT{{ end }} {{ if .responseTPOT }},:responseTPOT{{ end }} {{ if .responseOTPS }},:responseOTPS{{ end }} {{ if .latency }},:latency{{ end }} {{ if .endpoint }},:endpoint{{ end }} );\r\nselect last_insert_rowid();\r\n"))
	sqlTmplGetRequest       = template.Must(__PersistenceBaseTemplate.New("GetRequest").Parse("select * from moonshot_requests where 1 = 1 {{ if .id }} and id = :id {{ end }} {{ if .chatcmpl }} and moonshot_id = :chatcmpl {{ end }} {{ if .requestid }} and moonshot_request_id = :requestid {{ end }} ;\r\n"))
)

func (__imp *implPersistence) createTable() error {
	var (
		errcreateTable     error
		argListcreateTable = make(__rt.Arguments, 0, 8)
	)

	argListcreateTable = __rt.Arguments{}

	querycreateTable := "create table if not exists moonshot_requests ( id                     integer not null constraint moonshot_requests_pk primary key autoincrement, request_method         text    not null, request_path           text    not null, request_query          text    not null, request_content_type   text, request_id             text, moonshot_id            text, moonshot_gid           text, moonshot_uid           text, moonshot_request_id    text, moonshot_server_timing integer, response_status_code   integer, response_content_type  text, request_header         text, request_body           text, response_header        text, response_body          text, error                  text, response_ttft          integer, response_tpot          integer, response_otps          real, latency                integer, endpoint               text, created_at             text    default (datetime('now', 'localtime')) not null ); create table if not exists moonshot_caches ( id                     integer not null constraint moonshot_requests_pk primary key autoincrement, cache_id               text    not null, hash                   text    not null, n_bytes                integer not null, k_ident                text    not null, created_at             text    default (datetime('now', 'localtime')) not null, updated_at             text )\r\n"

	txcreateTable, errcreateTable := __imp.__core.Beginx()
	if errcreateTable != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("createTable"), errcreateTable)
	}
	if !__imp.__withTx {
		defer txcreateTable.Rollback()
	}

	offsetcreateTable := 0
	argscreateTable := __rt.MergeArgs(argListcreateTable...)

	sqlSlicecreateTable := __rt.Split(querycreateTable, ";")
	for indexcreateTable, splitSqlcreateTable := range sqlSlicecreateTable {
		_ = indexcreateTable

		countcreateTable := __rt.Count(splitSqlcreateTable, "?")

		_, errcreateTable = txcreateTable.Exec(splitSqlcreateTable, argscreateTable[offsetcreateTable:offsetcreateTable+countcreateTable]...)

		if errcreateTable != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("createTable"), splitSqlcreateTable, errcreateTable)
		}

		offsetcreateTable += countcreateTable
	}

	if !__imp.__withTx {
		if errcreateTable := txcreateTable.Commit(); errcreateTable != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("createTable"), errcreateTable)
		}
	}

	return nil
}

func (__imp *implPersistence) inspectTable() ([]*tableInfo, error) {
	var (
		v0inspectTable      []*tableInfo
		errinspectTable     error
		argListinspectTable = make(__rt.Arguments, 0, 8)
	)

	argListinspectTable = __rt.Arguments{}

	queryinspectTable := "pragma table_info(moonshot_requests);\r\n"

	txinspectTable, errinspectTable := __imp.__core.Beginx()
	if errinspectTable != nil {
		return v0inspectTable, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("inspectTable"), errinspectTable)
	}
	if !__imp.__withTx {
		defer txinspectTable.Rollback()
	}

	offsetinspectTable := 0
	argsinspectTable := __rt.MergeArgs(argListinspectTable...)

	sqlSliceinspectTable := __rt.Split(queryinspectTable, ";")
	for indexinspectTable, splitSqlinspectTable := range sqlSliceinspectTable {
		_ = indexinspectTable

		countinspectTable := __rt.Count(splitSqlinspectTable, "?")

		if indexinspectTable < len(sqlSliceinspectTable)-1 {
			_, errinspectTable = txinspectTable.Exec(splitSqlinspectTable, argsinspectTable[offsetinspectTable:offsetinspectTable+countinspectTable]...)
		} else {
			errinspectTable = txinspectTable.Select(&v0inspectTable, splitSqlinspectTable, argsinspectTable[offsetinspectTable:offsetinspectTable+countinspectTable]...)
		}

		if errinspectTable != nil {
			return v0inspectTable, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("inspectTable"), splitSqlinspectTable, errinspectTable)
		}

		offsetinspectTable += countinspectTable
	}

	if !__imp.__withTx {
		if errinspectTable := txinspectTable.Commit(); errinspectTable != nil {
			return v0inspectTable, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("inspectTable"), errinspectTable)
		}
	}

	return v0inspectTable, nil
}

func (__imp *implPersistence) addTTFTField() error {
	var (
		erraddTTFTField     error
		argListaddTTFTField = make(__rt.Arguments, 0, 8)
	)

	argListaddTTFTField = __rt.Arguments{}

	sqladdTTFTField := __rt.GetBuffer()
	defer __rt.PutBuffer(sqladdTTFTField)
	defer sqladdTTFTField.Reset()

	if erraddTTFTField = sqlTmpladdTTFTField.Execute(sqladdTTFTField, map[string]any{}); erraddTTFTField != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("addTTFTField"), erraddTTFTField)
	}

	queryaddTTFTField := sqladdTTFTField.String()

	txaddTTFTField, erraddTTFTField := __imp.__core.Beginx()
	if erraddTTFTField != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("addTTFTField"), erraddTTFTField)
	}
	if !__imp.__withTx {
		defer txaddTTFTField.Rollback()
	}

	offsetaddTTFTField := 0
	argsaddTTFTField := __rt.MergeArgs(argListaddTTFTField...)

	sqlSliceaddTTFTField := __rt.Split(queryaddTTFTField, ";")
	for indexaddTTFTField, splitSqladdTTFTField := range sqlSliceaddTTFTField {
		_ = indexaddTTFTField

		countaddTTFTField := __rt.Count(splitSqladdTTFTField, "?")

		_, erraddTTFTField = txaddTTFTField.Exec(splitSqladdTTFTField, argsaddTTFTField[offsetaddTTFTField:offsetaddTTFTField+countaddTTFTField]...)

		if erraddTTFTField != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("addTTFTField"), splitSqladdTTFTField, erraddTTFTField)
		}

		offsetaddTTFTField += countaddTTFTField
	}

	if !__imp.__withTx {
		if erraddTTFTField := txaddTTFTField.Commit(); erraddTTFTField != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("addTTFTField"), erraddTTFTField)
		}
	}

	return nil
}

func (__imp *implPersistence) addTPOTField() error {
	var (
		erraddTPOTField     error
		argListaddTPOTField = make(__rt.Arguments, 0, 8)
	)

	argListaddTPOTField = __rt.Arguments{}

	sqladdTPOTField := __rt.GetBuffer()
	defer __rt.PutBuffer(sqladdTPOTField)
	defer sqladdTPOTField.Reset()

	if erraddTPOTField = sqlTmpladdTPOTField.Execute(sqladdTPOTField, map[string]any{}); erraddTPOTField != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("addTPOTField"), erraddTPOTField)
	}

	queryaddTPOTField := sqladdTPOTField.String()

	txaddTPOTField, erraddTPOTField := __imp.__core.Beginx()
	if erraddTPOTField != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("addTPOTField"), erraddTPOTField)
	}
	if !__imp.__withTx {
		defer txaddTPOTField.Rollback()
	}

	offsetaddTPOTField := 0
	argsaddTPOTField := __rt.MergeArgs(argListaddTPOTField...)

	sqlSliceaddTPOTField := __rt.Split(queryaddTPOTField, ";")
	for indexaddTPOTField, splitSqladdTPOTField := range sqlSliceaddTPOTField {
		_ = indexaddTPOTField

		countaddTPOTField := __rt.Count(splitSqladdTPOTField, "?")

		_, erraddTPOTField = txaddTPOTField.Exec(splitSqladdTPOTField, argsaddTPOTField[offsetaddTPOTField:offsetaddTPOTField+countaddTPOTField]...)

		if erraddTPOTField != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("addTPOTField"), splitSqladdTPOTField, erraddTPOTField)
		}

		offsetaddTPOTField += countaddTPOTField
	}

	if !__imp.__withTx {
		if erraddTPOTField := txaddTPOTField.Commit(); erraddTPOTField != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("addTPOTField"), erraddTPOTField)
		}
	}

	return nil
}

func (__imp *implPersistence) addOTPSField() error {
	var (
		erraddOTPSField     error
		argListaddOTPSField = make(__rt.Arguments, 0, 8)
	)

	argListaddOTPSField = __rt.Arguments{}

	sqladdOTPSField := __rt.GetBuffer()
	defer __rt.PutBuffer(sqladdOTPSField)
	defer sqladdOTPSField.Reset()

	if erraddOTPSField = sqlTmpladdOTPSField.Execute(sqladdOTPSField, map[string]any{}); erraddOTPSField != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("addOTPSField"), erraddOTPSField)
	}

	queryaddOTPSField := sqladdOTPSField.String()

	txaddOTPSField, erraddOTPSField := __imp.__core.Beginx()
	if erraddOTPSField != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("addOTPSField"), erraddOTPSField)
	}
	if !__imp.__withTx {
		defer txaddOTPSField.Rollback()
	}

	offsetaddOTPSField := 0
	argsaddOTPSField := __rt.MergeArgs(argListaddOTPSField...)

	sqlSliceaddOTPSField := __rt.Split(queryaddOTPSField, ";")
	for indexaddOTPSField, splitSqladdOTPSField := range sqlSliceaddOTPSField {
		_ = indexaddOTPSField

		countaddOTPSField := __rt.Count(splitSqladdOTPSField, "?")

		_, erraddOTPSField = txaddOTPSField.Exec(splitSqladdOTPSField, argsaddOTPSField[offsetaddOTPSField:offsetaddOTPSField+countaddOTPSField]...)

		if erraddOTPSField != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("addOTPSField"), splitSqladdOTPSField, erraddOTPSField)
		}

		offsetaddOTPSField += countaddOTPSField
	}

	if !__imp.__withTx {
		if erraddOTPSField := txaddOTPSField.Commit(); erraddOTPSField != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("addOTPSField"), erraddOTPSField)
		}
	}

	return nil
}

func (__imp *implPersistence) addLatencyField() error {
	var (
		erraddLatencyField     error
		argListaddLatencyField = make(__rt.Arguments, 0, 8)
	)

	argListaddLatencyField = __rt.Arguments{}

	sqladdLatencyField := __rt.GetBuffer()
	defer __rt.PutBuffer(sqladdLatencyField)
	defer sqladdLatencyField.Reset()

	if erraddLatencyField = sqlTmpladdLatencyField.Execute(sqladdLatencyField, map[string]any{}); erraddLatencyField != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("addLatencyField"), erraddLatencyField)
	}

	queryaddLatencyField := sqladdLatencyField.String()

	txaddLatencyField, erraddLatencyField := __imp.__core.Beginx()
	if erraddLatencyField != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("addLatencyField"), erraddLatencyField)
	}
	if !__imp.__withTx {
		defer txaddLatencyField.Rollback()
	}

	offsetaddLatencyField := 0
	argsaddLatencyField := __rt.MergeArgs(argListaddLatencyField...)

	sqlSliceaddLatencyField := __rt.Split(queryaddLatencyField, ";")
	for indexaddLatencyField, splitSqladdLatencyField := range sqlSliceaddLatencyField {
		_ = indexaddLatencyField

		countaddLatencyField := __rt.Count(splitSqladdLatencyField, "?")

		_, erraddLatencyField = txaddLatencyField.Exec(splitSqladdLatencyField, argsaddLatencyField[offsetaddLatencyField:offsetaddLatencyField+countaddLatencyField]...)

		if erraddLatencyField != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("addLatencyField"), splitSqladdLatencyField, erraddLatencyField)
		}

		offsetaddLatencyField += countaddLatencyField
	}

	if !__imp.__withTx {
		if erraddLatencyField := txaddLatencyField.Commit(); erraddLatencyField != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("addLatencyField"), erraddLatencyField)
		}
	}

	return nil
}

func (__imp *implPersistence) addEndpointField() error {
	var (
		erraddEndpointField     error
		argListaddEndpointField = make(__rt.Arguments, 0, 8)
	)

	argListaddEndpointField = __rt.Arguments{}

	sqladdEndpointField := __rt.GetBuffer()
	defer __rt.PutBuffer(sqladdEndpointField)
	defer sqladdEndpointField.Reset()

	if erraddEndpointField = sqlTmpladdEndpointField.Execute(sqladdEndpointField, map[string]any{}); erraddEndpointField != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("addEndpointField"), erraddEndpointField)
	}

	queryaddEndpointField := sqladdEndpointField.String()

	txaddEndpointField, erraddEndpointField := __imp.__core.Beginx()
	if erraddEndpointField != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("addEndpointField"), erraddEndpointField)
	}
	if !__imp.__withTx {
		defer txaddEndpointField.Rollback()
	}

	offsetaddEndpointField := 0
	argsaddEndpointField := __rt.MergeArgs(argListaddEndpointField...)

	sqlSliceaddEndpointField := __rt.Split(queryaddEndpointField, ";")
	for indexaddEndpointField, splitSqladdEndpointField := range sqlSliceaddEndpointField {
		_ = indexaddEndpointField

		countaddEndpointField := __rt.Count(splitSqladdEndpointField, "?")

		_, erraddEndpointField = txaddEndpointField.Exec(splitSqladdEndpointField, argsaddEndpointField[offsetaddEndpointField:offsetaddEndpointField+countaddEndpointField]...)

		if erraddEndpointField != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("addEndpointField"), splitSqladdEndpointField, erraddEndpointField)
		}

		offsetaddEndpointField += countaddEndpointField
	}

	if !__imp.__withTx {
		if erraddEndpointField := txaddEndpointField.Commit(); erraddEndpointField != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("addEndpointField"), erraddEndpointField)
		}
	}

	return nil
}

func (__imp *implPersistence) Cleanup(before string) (sql.Result, error) {
	var (
		v0Cleanup  sql.Result
		errCleanup error
	)

	queryCleanup := "delete from moonshot_requests where created_at < :before;\r\n"

	txCleanup, errCleanup := __imp.__core.Beginx()
	if errCleanup != nil {
		return v0Cleanup, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("Cleanup"), errCleanup)
	}
	if !__imp.__withTx {
		defer txCleanup.Rollback()
	}

	argsCleanup := __rt.MergeNamedArgs(map[string]any{
		"before": before,
	})

	sqlSliceCleanup := __rt.Split(queryCleanup, ";")
	for indexCleanup, splitSqlCleanup := range sqlSliceCleanup {
		_ = indexCleanup

		var listArgsCleanup []interface{}

		splitSqlCleanup, listArgsCleanup, errCleanup = sqlx.Named(splitSqlCleanup, argsCleanup)
		if errCleanup != nil {
			return v0Cleanup, fmt.Errorf("error building %s query: %w", strconv.Quote("Cleanup"), errCleanup)
		}

		splitSqlCleanup, listArgsCleanup, errCleanup = sqlx.In(splitSqlCleanup, listArgsCleanup...)
		if errCleanup != nil {
			return v0Cleanup, fmt.Errorf("error building %s query: %w", strconv.Quote("Cleanup"), errCleanup)
		}

		v0Cleanup, errCleanup = txCleanup.Exec(splitSqlCleanup, listArgsCleanup...)

		if errCleanup != nil {
			return v0Cleanup, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("Cleanup"), splitSqlCleanup, errCleanup)
		}
	}

	if !__imp.__withTx {
		if errCleanup := txCleanup.Commit(); errCleanup != nil {
			return v0Cleanup, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("Cleanup"), errCleanup)
		}
	}

	return v0Cleanup, nil
}

func (__imp *implPersistence) Persistence(requestID string, requestContentType string, requestMethod string, requestPath string, requestQuery string, moonshotID string, moonshotGID string, moonshotUID string, moonshotRequestID string, moonshotServerTiming int, responseStatusCode int, responseContentType string, requestHeader string, requestBody string, responseHeader string, responseBody string, programError string, responseTTFT int, responseTPOT int, responseOTPS float64, createdAt string, latency time.Duration, endpoint string) (int64, error) {
	var (
		v0Persistence  int64
		errPersistence error
	)

	sqlPersistence := __rt.GetBuffer()
	defer __rt.PutBuffer(sqlPersistence)
	defer sqlPersistence.Reset()

	if errPersistence = sqlTmplPersistence.Execute(sqlPersistence, map[string]any{
		"requestID":            requestID,
		"requestContentType":   requestContentType,
		"requestMethod":        requestMethod,
		"requestPath":          requestPath,
		"requestQuery":         requestQuery,
		"moonshotID":           moonshotID,
		"moonshotGID":          moonshotGID,
		"moonshotUID":          moonshotUID,
		"moonshotRequestID":    moonshotRequestID,
		"moonshotServerTiming": moonshotServerTiming,
		"responseStatusCode":   responseStatusCode,
		"responseContentType":  responseContentType,
		"requestHeader":        requestHeader,
		"requestBody":          requestBody,
		"responseHeader":       responseHeader,
		"responseBody":         responseBody,
		"programError":         programError,
		"responseTTFT":         responseTTFT,
		"responseTPOT":         responseTPOT,
		"responseOTPS":         responseOTPS,
		"createdAt":            createdAt,
		"latency":              latency,
		"endpoint":             endpoint,
	}); errPersistence != nil {
		return v0Persistence, fmt.Errorf("error executing %s template: %w", strconv.Quote("Persistence"), errPersistence)
	}

	queryPersistence := sqlPersistence.String()

	txPersistence, errPersistence := __imp.__core.Beginx()
	if errPersistence != nil {
		return v0Persistence, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("Persistence"), errPersistence)
	}
	if !__imp.__withTx {
		defer txPersistence.Rollback()
	}

	argsPersistence := __rt.MergeNamedArgs(map[string]any{
		"requestID":            requestID,
		"requestContentType":   requestContentType,
		"requestMethod":        requestMethod,
		"requestPath":          requestPath,
		"requestQuery":         requestQuery,
		"moonshotID":           moonshotID,
		"moonshotGID":          moonshotGID,
		"moonshotUID":          moonshotUID,
		"moonshotRequestID":    moonshotRequestID,
		"moonshotServerTiming": moonshotServerTiming,
		"responseStatusCode":   responseStatusCode,
		"responseContentType":  responseContentType,
		"requestHeader":        requestHeader,
		"requestBody":          requestBody,
		"responseHeader":       responseHeader,
		"responseBody":         responseBody,
		"programError":         programError,
		"responseTTFT":         responseTTFT,
		"responseTPOT":         responseTPOT,
		"responseOTPS":         responseOTPS,
		"createdAt":            createdAt,
		"latency":              latency,
		"endpoint":             endpoint,
	})

	sqlSlicePersistence := __rt.Split(queryPersistence, ";")
	for indexPersistence, splitSqlPersistence := range sqlSlicePersistence {
		_ = indexPersistence

		var listArgsPersistence []interface{}

		splitSqlPersistence, listArgsPersistence, errPersistence = sqlx.Named(splitSqlPersistence, argsPersistence)
		if errPersistence != nil {
			return v0Persistence, fmt.Errorf("error building %s query: %w", strconv.Quote("Persistence"), errPersistence)
		}

		splitSqlPersistence, listArgsPersistence, errPersistence = sqlx.In(splitSqlPersistence, listArgsPersistence...)
		if errPersistence != nil {
			return v0Persistence, fmt.Errorf("error building %s query: %w", strconv.Quote("Persistence"), errPersistence)
		}

		if indexPersistence < len(sqlSlicePersistence)-1 {
			_, errPersistence = txPersistence.Exec(splitSqlPersistence, listArgsPersistence...)
		} else {
			errPersistence = txPersistence.Get(&v0Persistence, splitSqlPersistence, listArgsPersistence...)
		}

		if errPersistence != nil {
			return v0Persistence, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("Persistence"), splitSqlPersistence, errPersistence)
		}
	}

	if !__imp.__withTx {
		if errPersistence := txPersistence.Commit(); errPersistence != nil {
			return v0Persistence, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("Persistence"), errPersistence)
		}
	}

	return v0Persistence, nil
}

func (__imp *implPersistence) ListRequests(n int64, chatOnly bool, predicate string) ([]*Request, error) {
	var (
		v0ListRequests      []*Request
		errListRequests     error
		argListListRequests = make(__rt.Arguments, 0, 8)
	)

	__ListRequestsBindFunc := func(arg any) string {
		argListListRequests = append(argListListRequests, arg)
		return __rt.BindVars(len(__rt.MergeArgs(arg)))
	}
	sqlTmplListRequests := template.Must(template.New("ListRequests").Funcs(template.FuncMap{"bind": __ListRequestsBindFunc, "bindvars": __rt.BindVars, "fields": tableFields}).Parse("select * from ( select {{ fields \"response_body\" }}, iif( response_content_type = 'text/event-stream' and response_body is not null, merge_cmpl(response_body), response_body ) as response_body from moonshot_requests ) where 1 = 1 {{ if .chatOnly }} and request_path like '%/chat/completions' {{ end }} {{ if .predicate }} and ({{ .predicate }}) {{ end }} order by id desc {{ if .n }} limit {{ bind .n }} {{ end }} ;\r\n"))

	sqlListRequests := __rt.GetBuffer()
	defer __rt.PutBuffer(sqlListRequests)
	defer sqlListRequests.Reset()

	if errListRequests = sqlTmplListRequests.Execute(sqlListRequests, map[string]any{
		"n":         n,
		"chatOnly":  chatOnly,
		"predicate": predicate,
	}); errListRequests != nil {
		return v0ListRequests, fmt.Errorf("error executing %s template: %w", strconv.Quote("ListRequests"), errListRequests)
	}

	queryListRequests := sqlListRequests.String()

	txListRequests, errListRequests := __imp.__core.Beginx()
	if errListRequests != nil {
		return v0ListRequests, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("ListRequests"), errListRequests)
	}
	if !__imp.__withTx {
		defer txListRequests.Rollback()
	}

	offsetListRequests := 0
	argsListRequests := __rt.MergeArgs(argListListRequests...)

	sqlSliceListRequests := __rt.Split(queryListRequests, ";")
	for indexListRequests, splitSqlListRequests := range sqlSliceListRequests {
		_ = indexListRequests

		countListRequests := __rt.Count(splitSqlListRequests, "?")

		if indexListRequests < len(sqlSliceListRequests)-1 {
			_, errListRequests = txListRequests.Exec(splitSqlListRequests, argsListRequests[offsetListRequests:offsetListRequests+countListRequests]...)
		} else {
			errListRequests = txListRequests.Select(&v0ListRequests, splitSqlListRequests, argsListRequests[offsetListRequests:offsetListRequests+countListRequests]...)
		}

		if errListRequests != nil {
			return v0ListRequests, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("ListRequests"), splitSqlListRequests, errListRequests)
		}

		offsetListRequests += countListRequests
	}

	if !__imp.__withTx {
		if errListRequests := txListRequests.Commit(); errListRequests != nil {
			return v0ListRequests, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("ListRequests"), errListRequests)
		}
	}

	return v0ListRequests, nil
}

func (__imp *implPersistence) GetRequest(id int64, chatcmpl string, requestid string) (*Request, error) {
	var (
		v0GetRequest  = new(Request)
		errGetRequest error
	)

	sqlGetRequest := __rt.GetBuffer()
	defer __rt.PutBuffer(sqlGetRequest)
	defer sqlGetRequest.Reset()

	if errGetRequest = sqlTmplGetRequest.Execute(sqlGetRequest, map[string]any{
		"id":        id,
		"chatcmpl":  chatcmpl,
		"requestid": requestid,
	}); errGetRequest != nil {
		return v0GetRequest, fmt.Errorf("error executing %s template: %w", strconv.Quote("GetRequest"), errGetRequest)
	}

	queryGetRequest := sqlGetRequest.String()

	txGetRequest, errGetRequest := __imp.__core.Beginx()
	if errGetRequest != nil {
		return v0GetRequest, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("GetRequest"), errGetRequest)
	}
	if !__imp.__withTx {
		defer txGetRequest.Rollback()
	}

	argsGetRequest := __rt.MergeNamedArgs(map[string]any{
		"id":        id,
		"chatcmpl":  chatcmpl,
		"requestid": requestid,
	})

	sqlSliceGetRequest := __rt.Split(queryGetRequest, ";")
	for indexGetRequest, splitSqlGetRequest := range sqlSliceGetRequest {
		_ = indexGetRequest

		var listArgsGetRequest []interface{}

		splitSqlGetRequest, listArgsGetRequest, errGetRequest = sqlx.Named(splitSqlGetRequest, argsGetRequest)
		if errGetRequest != nil {
			return v0GetRequest, fmt.Errorf("error building %s query: %w", strconv.Quote("GetRequest"), errGetRequest)
		}

		splitSqlGetRequest, listArgsGetRequest, errGetRequest = sqlx.In(splitSqlGetRequest, listArgsGetRequest...)
		if errGetRequest != nil {
			return v0GetRequest, fmt.Errorf("error building %s query: %w", strconv.Quote("GetRequest"), errGetRequest)
		}

		if indexGetRequest < len(sqlSliceGetRequest)-1 {
			_, errGetRequest = txGetRequest.Exec(splitSqlGetRequest, listArgsGetRequest...)
		} else {
			errGetRequest = txGetRequest.Get(v0GetRequest, splitSqlGetRequest, listArgsGetRequest...)
		}

		if errGetRequest != nil {
			return v0GetRequest, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("GetRequest"), splitSqlGetRequest, errGetRequest)
		}
	}

	if !__imp.__withTx {
		if errGetRequest := txGetRequest.Commit(); errGetRequest != nil {
			return v0GetRequest, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("GetRequest"), errGetRequest)
		}
	}

	return v0GetRequest, nil
}

func (__imp *implPersistence) SetCache(ctx context.Context, cacheID string, hash string, nBytes int, kIdent string, createdAt string) error {
	var (
		errSetCache error
	)

	querySetCache := "insert into moonshot_caches ( cache_id, hash, n_bytes, k_ident, created_at ) values ( :cacheID, :hash, :nBytes, :kIdent, :createdAt );\r\n"

	txSetCache, errSetCache := __imp.__core.BeginTxx(ctx, nil)
	if errSetCache != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("SetCache"), errSetCache)
	}
	if !__imp.__withTx {
		defer txSetCache.Rollback()
	}

	argsSetCache := __rt.MergeNamedArgs(map[string]any{
		"cacheID":   cacheID,
		"hash":      hash,
		"nBytes":    nBytes,
		"kIdent":    kIdent,
		"createdAt": createdAt,
	})

	sqlSliceSetCache := __rt.Split(querySetCache, ";")
	for indexSetCache, splitSqlSetCache := range sqlSliceSetCache {
		_ = indexSetCache

		var listArgsSetCache []interface{}

		splitSqlSetCache, listArgsSetCache, errSetCache = sqlx.Named(splitSqlSetCache, argsSetCache)
		if errSetCache != nil {
			return fmt.Errorf("error building %s query: %w", strconv.Quote("SetCache"), errSetCache)
		}

		splitSqlSetCache, listArgsSetCache, errSetCache = sqlx.In(splitSqlSetCache, listArgsSetCache...)
		if errSetCache != nil {
			return fmt.Errorf("error building %s query: %w", strconv.Quote("SetCache"), errSetCache)
		}

		_, errSetCache = txSetCache.ExecContext(ctx, splitSqlSetCache, listArgsSetCache...)

		if errSetCache != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("SetCache"), splitSqlSetCache, errSetCache)
		}
	}

	if !__imp.__withTx {
		if errSetCache := txSetCache.Commit(); errSetCache != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("SetCache"), errSetCache)
		}
	}

	return nil
}

func (__imp *implPersistence) GetCacheByHashList(ctx context.Context, hashList []string, nBytes int, kIdent string) (string, error) {
	var (
		v0GetCacheByHashList  string
		errGetCacheByHashList error
	)

	queryGetCacheByHashList := "select cache_id from moonshot_caches where hash in (:hashList) and n_bytes > :nBytes and k_ident = :kIdent order by n_bytes desc limit 1;\r\n"

	txGetCacheByHashList, errGetCacheByHashList := __imp.__core.BeginTxx(ctx, nil)
	if errGetCacheByHashList != nil {
		return v0GetCacheByHashList, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("GetCacheByHashList"), errGetCacheByHashList)
	}
	if !__imp.__withTx {
		defer txGetCacheByHashList.Rollback()
	}

	argsGetCacheByHashList := __rt.MergeNamedArgs(map[string]any{
		"hashList": hashList,
		"nBytes":   nBytes,
		"kIdent":   kIdent,
	})

	sqlSliceGetCacheByHashList := __rt.Split(queryGetCacheByHashList, ";")
	for indexGetCacheByHashList, splitSqlGetCacheByHashList := range sqlSliceGetCacheByHashList {
		_ = indexGetCacheByHashList

		var listArgsGetCacheByHashList []interface{}

		splitSqlGetCacheByHashList, listArgsGetCacheByHashList, errGetCacheByHashList = sqlx.Named(splitSqlGetCacheByHashList, argsGetCacheByHashList)
		if errGetCacheByHashList != nil {
			return v0GetCacheByHashList, fmt.Errorf("error building %s query: %w", strconv.Quote("GetCacheByHashList"), errGetCacheByHashList)
		}

		splitSqlGetCacheByHashList, listArgsGetCacheByHashList, errGetCacheByHashList = sqlx.In(splitSqlGetCacheByHashList, listArgsGetCacheByHashList...)
		if errGetCacheByHashList != nil {
			return v0GetCacheByHashList, fmt.Errorf("error building %s query: %w", strconv.Quote("GetCacheByHashList"), errGetCacheByHashList)
		}

		if indexGetCacheByHashList < len(sqlSliceGetCacheByHashList)-1 {
			_, errGetCacheByHashList = txGetCacheByHashList.ExecContext(ctx, splitSqlGetCacheByHashList, listArgsGetCacheByHashList...)
		} else {
			errGetCacheByHashList = txGetCacheByHashList.GetContext(ctx, &v0GetCacheByHashList, splitSqlGetCacheByHashList, listArgsGetCacheByHashList...)
		}

		if errGetCacheByHashList != nil {
			return v0GetCacheByHashList, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("GetCacheByHashList"), splitSqlGetCacheByHashList, errGetCacheByHashList)
		}
	}

	if !__imp.__withTx {
		if errGetCacheByHashList := txGetCacheByHashList.Commit(); errGetCacheByHashList != nil {
			return v0GetCacheByHashList, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("GetCacheByHashList"), errGetCacheByHashList)
		}
	}

	return v0GetCacheByHashList, nil
}

func (__imp *implPersistence) UpdateCache(cacheID string, updatedAt string) error {
	var (
		errUpdateCache error
	)

	queryUpdateCache := "update moonshot_caches set updated_at = :updatedAt where cache_id = :cacheID;\r\n"

	txUpdateCache, errUpdateCache := __imp.__core.Beginx()
	if errUpdateCache != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("UpdateCache"), errUpdateCache)
	}
	if !__imp.__withTx {
		defer txUpdateCache.Rollback()
	}

	argsUpdateCache := __rt.MergeNamedArgs(map[string]any{
		"cacheID":   cacheID,
		"updatedAt": updatedAt,
	})

	sqlSliceUpdateCache := __rt.Split(queryUpdateCache, ";")
	for indexUpdateCache, splitSqlUpdateCache := range sqlSliceUpdateCache {
		_ = indexUpdateCache

		var listArgsUpdateCache []interface{}

		splitSqlUpdateCache, listArgsUpdateCache, errUpdateCache = sqlx.Named(splitSqlUpdateCache, argsUpdateCache)
		if errUpdateCache != nil {
			return fmt.Errorf("error building %s query: %w", strconv.Quote("UpdateCache"), errUpdateCache)
		}

		splitSqlUpdateCache, listArgsUpdateCache, errUpdateCache = sqlx.In(splitSqlUpdateCache, listArgsUpdateCache...)
		if errUpdateCache != nil {
			return fmt.Errorf("error building %s query: %w", strconv.Quote("UpdateCache"), errUpdateCache)
		}

		_, errUpdateCache = txUpdateCache.Exec(splitSqlUpdateCache, listArgsUpdateCache...)

		if errUpdateCache != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("UpdateCache"), splitSqlUpdateCache, errUpdateCache)
		}
	}

	if !__imp.__withTx {
		if errUpdateCache := txUpdateCache.Commit(); errUpdateCache != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("UpdateCache"), errUpdateCache)
		}
	}

	return nil
}

func (__imp *implPersistence) RemoveInactiveCaches(kIdent string, before string) ([]string, error) {
	var (
		v0RemoveInactiveCaches  []string
		errRemoveInactiveCaches error
	)

	queryRemoveInactiveCaches := "delete from moonshot_caches where k_ident = :kIdent and ( updated_at < :before or (updated_at is null and created_at < :before) );\r\n"

	txRemoveInactiveCaches, errRemoveInactiveCaches := __imp.__core.Beginx()
	if errRemoveInactiveCaches != nil {
		return v0RemoveInactiveCaches, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("RemoveInactiveCaches"), errRemoveInactiveCaches)
	}
	if !__imp.__withTx {
		defer txRemoveInactiveCaches.Rollback()
	}

	argsRemoveInactiveCaches := __rt.MergeNamedArgs(map[string]any{
		"kIdent": kIdent,
		"before": before,
	})

	sqlSliceRemoveInactiveCaches := __rt.Split(queryRemoveInactiveCaches, ";")
	for indexRemoveInactiveCaches, splitSqlRemoveInactiveCaches := range sqlSliceRemoveInactiveCaches {
		_ = indexRemoveInactiveCaches

		var listArgsRemoveInactiveCaches []interface{}

		splitSqlRemoveInactiveCaches, listArgsRemoveInactiveCaches, errRemoveInactiveCaches = sqlx.Named(splitSqlRemoveInactiveCaches, argsRemoveInactiveCaches)
		if errRemoveInactiveCaches != nil {
			return v0RemoveInactiveCaches, fmt.Errorf("error building %s query: %w", strconv.Quote("RemoveInactiveCaches"), errRemoveInactiveCaches)
		}

		splitSqlRemoveInactiveCaches, listArgsRemoveInactiveCaches, errRemoveInactiveCaches = sqlx.In(splitSqlRemoveInactiveCaches, listArgsRemoveInactiveCaches...)
		if errRemoveInactiveCaches != nil {
			return v0RemoveInactiveCaches, fmt.Errorf("error building %s query: %w", strconv.Quote("RemoveInactiveCaches"), errRemoveInactiveCaches)
		}

		if indexRemoveInactiveCaches < len(sqlSliceRemoveInactiveCaches)-1 {
			_, errRemoveInactiveCaches = txRemoveInactiveCaches.Exec(splitSqlRemoveInactiveCaches, listArgsRemoveInactiveCaches...)
		} else {
			errRemoveInactiveCaches = txRemoveInactiveCaches.Select(&v0RemoveInactiveCaches, splitSqlRemoveInactiveCaches, listArgsRemoveInactiveCaches...)
		}

		if errRemoveInactiveCaches != nil {
			return v0RemoveInactiveCaches, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("RemoveInactiveCaches"), splitSqlRemoveInactiveCaches, errRemoveInactiveCaches)
		}
	}

	if !__imp.__withTx {
		if errRemoveInactiveCaches := txRemoveInactiveCaches.Commit(); errRemoveInactiveCaches != nil {
			return v0RemoveInactiveCaches, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("RemoveInactiveCaches"), errRemoveInactiveCaches)
		}
	}

	return v0RemoveInactiveCaches, nil
}

type PersistenceCoreInterface interface {
	Beginx() (*sqlx.Tx, error)
	BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error)
	Exec(query string, args ...interface{}) (sql.Result, error)
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	Get(dest interface{}, query string, args ...interface{}) error
	GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
	Select(dest interface{}, query string, args ...interface{}) error
	SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

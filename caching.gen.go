// Code generated by defc, DO NOT EDIT.

package main

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/textproto"
	"text/template"

	__rt "github.com/x5iu/defc/runtime"
	defc "github.com/x5iu/defc/runtime"
)

const (
	CallerCreate = "Create"
	CallerGet    = "Get"
	CallerDelete = "Delete"
)

func NewCaching() Caching {
	return &implCaching{}
}

type implCaching struct{}

var (
	addrTmplCreate   = template.Must(template.New("AddressCreate").Funcs(template.FuncMap{"endpoint": getEndpoint}).Parse("{{ endpoint }}/v1/caching"))
	headerTmplCreate = template.Must(template.New("HeaderCreate").Funcs(template.FuncMap{"endpoint": getEndpoint}).Parse("Content-Type: application/json\r\nAuthorization: Bearer {{ .key }}\r\n\r\n"))
	addrTmplGet      = template.Must(template.New("AddressGet").Funcs(template.FuncMap{"endpoint": getEndpoint}).Parse("{{ endpoint }}/v1/caching/{{ .id }}"))
	headerTmplGet    = template.Must(template.New("HeaderGet").Funcs(template.FuncMap{"endpoint": getEndpoint}).Parse("Authorization: Bearer {{ .key }}\r\n\r\n"))
	addrTmplDelete   = template.Must(template.New("AddressDelete").Funcs(template.FuncMap{"endpoint": getEndpoint}).Parse("{{ endpoint }}/v1/caching/{{ .id }}"))
	headerTmplDelete = template.Must(template.New("HeaderDelete").Funcs(template.FuncMap{"endpoint": getEndpoint}).Parse("Authorization: Bearer {{ .key }}\r\n\r\n"))
)

func (*implCaching) Response() *defc.JSON {
	return new(defc.JSON)
}

func (__imp *implCaching) Create(ctx context.Context, key string, cache *Cache) error {

	addrCreate := __rt.GetBuffer()
	defer __rt.PutBuffer(addrCreate)
	defer addrCreate.Reset()

	headerCreate := __rt.GetBuffer()
	defer __rt.PutBuffer(headerCreate)
	defer headerCreate.Reset()

	responseBodyCreate := __rt.GetBuffer()
	defer __rt.PutBuffer(responseBodyCreate)
	defer responseBodyCreate.Reset()

	var (
		errCreate          error
		httpResponseCreate *http.Response
		responseCreate     __rt.Response = __imp.Response()
	)

	if errCreate = addrTmplCreate.Execute(addrCreate, map[string]any{
		"ctx":   ctx,
		"key":   key,
		"cache": cache,
	}); errCreate != nil {
		return fmt.Errorf("error building 'Create' url: %w", errCreate)
	}

	if errCreate = headerTmplCreate.Execute(headerCreate, map[string]any{
		"ctx":   ctx,
		"key":   key,
		"cache": cache,
	}); errCreate != nil {
		return fmt.Errorf("error building 'Create' header: %w", errCreate)
	}
	bufReaderCreate := bufio.NewReader(headerCreate)
	mimeHeaderCreate, errCreate := textproto.NewReader(bufReaderCreate).ReadMIMEHeader()
	if errCreate != nil {
		return fmt.Errorf("error reading 'Create' header: %w", errCreate)
	}

	urlCreate := addrCreate.String()
	requestCreate, errCreate := http.NewRequestWithContext(ctx, "POST", urlCreate, cache)
	if errCreate != nil {
		return fmt.Errorf("error building 'Create' request: %w", errCreate)
	}

	for kCreate, vvCreate := range mimeHeaderCreate {
		for _, vCreate := range vvCreate {
			requestCreate.Header.Add(kCreate, vCreate)
		}
	}

	httpResponseCreate, errCreate = http.DefaultClient.Do(requestCreate)

	if errCreate != nil {
		return fmt.Errorf("error sending 'Create' request: %w", errCreate)
	}

	if _, errCreate = io.Copy(responseBodyCreate, httpResponseCreate.Body); errCreate != nil {
		httpResponseCreate.Body.Close()
		return fmt.Errorf("error copying 'Create' response body: %w", errCreate)
	} else {
		httpResponseCreate.Body.Close()
	}

	if httpResponseCreate.StatusCode < 200 || httpResponseCreate.StatusCode > 299 {
		return fmt.Errorf("response status code %d for 'Create' with body: \n\n%s\n\n", httpResponseCreate.StatusCode, responseBodyCreate.String())
	}

	if errCreate = responseCreate.FromBytes("Create", responseBodyCreate.Bytes()); errCreate != nil {
		return fmt.Errorf("error converting 'Create' response: %w", errCreate)
	}

	addrCreate.Reset()
	headerCreate.Reset()
	responseBodyCreate.Reset()

	if errCreate = responseCreate.Err(); errCreate != nil {
		return fmt.Errorf("error returned from 'Create' response: %w", errCreate)
	}

	if errCreate = responseCreate.ScanValues(cache); errCreate != nil {
		return fmt.Errorf("error scanning value from 'Create' response: %w", errCreate)
	}

	return nil
}

func (__imp *implCaching) Get(ctx context.Context, key string, id string) (*Cache, error) {

	addrGet := __rt.GetBuffer()
	defer __rt.PutBuffer(addrGet)
	defer addrGet.Reset()

	headerGet := __rt.GetBuffer()
	defer __rt.PutBuffer(headerGet)
	defer headerGet.Reset()

	responseBodyGet := __rt.GetBuffer()
	defer __rt.PutBuffer(responseBodyGet)
	defer responseBodyGet.Reset()

	var (
		v0Get           = new(Cache)
		errGet          error
		httpResponseGet *http.Response
		responseGet     __rt.Response = __imp.Response()
	)

	if errGet = addrTmplGet.Execute(addrGet, map[string]any{
		"ctx": ctx,
		"key": key,
		"id":  id,
	}); errGet != nil {
		return v0Get, fmt.Errorf("error building 'Get' url: %w", errGet)
	}

	if errGet = headerTmplGet.Execute(headerGet, map[string]any{
		"ctx": ctx,
		"key": key,
		"id":  id,
	}); errGet != nil {
		return v0Get, fmt.Errorf("error building 'Get' header: %w", errGet)
	}
	bufReaderGet := bufio.NewReader(headerGet)
	mimeHeaderGet, errGet := textproto.NewReader(bufReaderGet).ReadMIMEHeader()
	if errGet != nil {
		return v0Get, fmt.Errorf("error reading 'Get' header: %w", errGet)
	}

	urlGet := addrGet.String()
	requestGet, errGet := http.NewRequestWithContext(ctx, "GET", urlGet, http.NoBody)
	if errGet != nil {
		return v0Get, fmt.Errorf("error building 'Get' request: %w", errGet)
	}

	for kGet, vvGet := range mimeHeaderGet {
		for _, vGet := range vvGet {
			requestGet.Header.Add(kGet, vGet)
		}
	}

	httpResponseGet, errGet = http.DefaultClient.Do(requestGet)

	if errGet != nil {
		return v0Get, fmt.Errorf("error sending 'Get' request: %w", errGet)
	}

	if _, errGet = io.Copy(responseBodyGet, httpResponseGet.Body); errGet != nil {
		httpResponseGet.Body.Close()
		return v0Get, fmt.Errorf("error copying 'Get' response body: %w", errGet)
	} else {
		httpResponseGet.Body.Close()
	}

	if httpResponseGet.StatusCode < 200 || httpResponseGet.StatusCode > 299 {
		return v0Get, fmt.Errorf("response status code %d for 'Get' with body: \n\n%s\n\n", httpResponseGet.StatusCode, responseBodyGet.String())
	}

	if errGet = responseGet.FromBytes("Get", responseBodyGet.Bytes()); errGet != nil {
		return v0Get, fmt.Errorf("error converting 'Get' response: %w", errGet)
	}

	addrGet.Reset()
	headerGet.Reset()
	responseBodyGet.Reset()

	if errGet = responseGet.Err(); errGet != nil {
		return v0Get, fmt.Errorf("error returned from 'Get' response: %w", errGet)
	}

	if errGet = responseGet.ScanValues(v0Get); errGet != nil {
		return v0Get, fmt.Errorf("error scanning value from 'Get' response: %w", errGet)
	}

	return v0Get, nil
}

func (__imp *implCaching) Delete(ctx context.Context, key string, id string) error {

	addrDelete := __rt.GetBuffer()
	defer __rt.PutBuffer(addrDelete)
	defer addrDelete.Reset()

	headerDelete := __rt.GetBuffer()
	defer __rt.PutBuffer(headerDelete)
	defer headerDelete.Reset()

	responseBodyDelete := __rt.GetBuffer()
	defer __rt.PutBuffer(responseBodyDelete)
	defer responseBodyDelete.Reset()

	var (
		errDelete          error
		httpResponseDelete *http.Response
		responseDelete     __rt.Response = __imp.Response()
	)

	if errDelete = addrTmplDelete.Execute(addrDelete, map[string]any{
		"ctx": ctx,
		"key": key,
		"id":  id,
	}); errDelete != nil {
		return fmt.Errorf("error building 'Delete' url: %w", errDelete)
	}

	if errDelete = headerTmplDelete.Execute(headerDelete, map[string]any{
		"ctx": ctx,
		"key": key,
		"id":  id,
	}); errDelete != nil {
		return fmt.Errorf("error building 'Delete' header: %w", errDelete)
	}
	bufReaderDelete := bufio.NewReader(headerDelete)
	mimeHeaderDelete, errDelete := textproto.NewReader(bufReaderDelete).ReadMIMEHeader()
	if errDelete != nil {
		return fmt.Errorf("error reading 'Delete' header: %w", errDelete)
	}

	urlDelete := addrDelete.String()
	requestDelete, errDelete := http.NewRequestWithContext(ctx, "DELETE", urlDelete, http.NoBody)
	if errDelete != nil {
		return fmt.Errorf("error building 'Delete' request: %w", errDelete)
	}

	for kDelete, vvDelete := range mimeHeaderDelete {
		for _, vDelete := range vvDelete {
			requestDelete.Header.Add(kDelete, vDelete)
		}
	}

	httpResponseDelete, errDelete = http.DefaultClient.Do(requestDelete)

	if errDelete != nil {
		return fmt.Errorf("error sending 'Delete' request: %w", errDelete)
	}

	if _, errDelete = io.Copy(responseBodyDelete, httpResponseDelete.Body); errDelete != nil {
		httpResponseDelete.Body.Close()
		return fmt.Errorf("error copying 'Delete' response body: %w", errDelete)
	} else {
		httpResponseDelete.Body.Close()
	}

	if httpResponseDelete.StatusCode < 200 || httpResponseDelete.StatusCode > 299 {
		return fmt.Errorf("response status code %d for 'Delete' with body: \n\n%s\n\n", httpResponseDelete.StatusCode, responseBodyDelete.String())
	}

	if errDelete = responseDelete.FromBytes("Delete", responseBodyDelete.Bytes()); errDelete != nil {
		return fmt.Errorf("error converting 'Delete' response: %w", errDelete)
	}

	addrDelete.Reset()
	headerDelete.Reset()
	responseBodyDelete.Reset()

	if errDelete = responseDelete.Err(); errDelete != nil {
		return fmt.Errorf("error returned from 'Delete' response: %w", errDelete)
	}

	if errDelete = responseDelete.ScanValues(); errDelete != nil {
		return fmt.Errorf("error scanning value from 'Delete' response: %w", errDelete)
	}

	return nil
}
